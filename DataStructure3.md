# 第5章 树和二叉树

![1676448529917](DataStructure3.assets/1676448529917.png)

![1676448583848](DataStructure3.assets/1676448583848.png)

## 5.1 树和二叉树的定义

### 5.1.1 树的定义

树(Tree)是n(n>=0)个结点的有限集, 它或为空树(n= 0); 或为非空树，对于非空树T:

(1) 有且仅有一个称之为根的结点；
(2) 除根结点以外的其余结点可分为m(m>0)个互不相交的有限集T1, T2 , …, Tm, 其中每一个集合本身又是一棵树， 并且称为根的子树(SubTree)。

![1676449829436](DataStructure3.assets/1676449829436.png)

树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了**树的固有特性**。

### 5.1.2 树的基本术语

(1) `结点`：树中的一个`独立单元`。包含一个`数据元素`及`若干指向其子树的分支`，如图5.1(b) 中的A , B, C, D等. (下面术语中均以图5.1 (b) 为例来说明). 根节点: 非空树中没有前驱结点的结点.

(2)`结点的度`：结点拥有的`子树数`称为结点的度。例如，A的度为3, C的度为1, F的度为0。

(3)`树的度`： 树的度是`树内各结点度的最大值`。图5.1 (b) 所示的树的度为3。

(4) `叶子`：`度为0的结点`称为叶子或`终端结点`。结点K 、L 、F 、G 、M 、I 、J都是树的叶子。

(5)` 非终端结点`：`度不为0的结点`称为非终端结点或`分支结点`。`除根结点之外`，非终端结点也称为`内部结点`。

(6)`双亲和孩子`：`结点的子树的根`称为该结点的孩子，相应地，该`结点称为孩子的双亲`。例如，B的双亲为A, B的孩子有E和F。

(7) `兄弟`：`同一个双亲的孩子之间`互称兄弟。例如，H 、I 和J互为兄弟。

(8) `祖先`：`从根到该结点所经分支上的所有结点`。例如， M 的祖先为A 、D 和H。

(9) `子孙`：`以某结点为根`的`子树中的任一结点`都称为该结点的子孙。如B的子孙为E 、K 、L和F。

(10) `层次`：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加1。

(11)`堂兄弟`：`双亲在同一层的结点`互为堂兄弟。例如，结点G 与E 、F、H 、I 、J互为堂兄弟。

(12)`树的深度`：`树中结点的最大层次`称为树的深度或高度。图5.1 (b)所示的树的深度为4。

(13)`有序树和无序树`：如果将树中结点的各子树看成从左至右是有次序的(即不能互换), 则称该树为有序树, 否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子.

(14)`森林`：是m (m>=0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。B,C,D 为根的树, 组成一个森林.
![1676451948491](DataStructure3.assets/1676451948491.png)

![1676451728603](DataStructure3.assets/1676451728603.png)

![1676451980616](DataStructure3.assets/1676451980616.png)

### 5.1.3 二叉树的定义

![1676452301070](DataStructure3.assets/1676452301070.png)

- 定义:

二叉树(Binary Tree)是n(n>=0)个结点所构成的有限集合, 它或为空树(n= 0); 或为非空树, 对于非空树T:

(1) 有且仅有一个称之为根的结点；
(2) 除根结点以外的其余结点分为两个互不相交的子集T1和T2, 分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。

二叉树与树一样具有递归性质，二叉树与树的区别主要有以下两点：
(1) 二叉树每个结点至多只有两棵子树或两个孩子 (即二叉树中不存在度大于2 的结点)；
(2) 二叉树的子树有左右之分, 其次序不能任意颠倒。

二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空树。

注意:

- 二叉树不是树的特殊情况, 它们是两个不同的东西.
- 二叉树结点的子树, 要区分左子树与右子树, 即使只有一棵树, 也必须要区分, 说明它是左子树还是右子树.
- 树中当结点只有一个孩子时, 就不必区分左右的次序问题. 这也是树与二叉树的主要区别.

![1676453064493](DataStructure3.assets/1676453064493.png)

![1676453142558](DataStructure3.assets/1676453142558.png)

![1676453173227](DataStructure3.assets/1676453173227.png)

## 5.2 案例引入

随着大数据时代的到来， 如何采用有效的数据压缩技术， 来节省数据文件的存储空间和网络传输时间越来越引起人们的重视。

案例5.1: 数据压缩问题。

![1676453394064](DataStructure3.assets/1676453394064.png)

案例5.2: 利用二叉树求解表达式的值。

![1676453403264](DataStructure3.assets/1676453403264.png)

## 5.3 树和二叉树的抽象数据类型定义

- 树的ADT

![1676453830979](DataStructure3.assets/1676453830979.png)

![1676453873780](DataStructure3.assets/1676453873780.png)

![1676453890017](DataStructure3.assets/1676453890017.png)

- 二叉树的ADT

> 二叉树是非常重要的一个数据结构, 跟前面链表, 顺序, 数组一样重要.

![1676454197075](DataStructure3.assets/1676454197075.png)
![1676454207962](DataStructure3.assets/1676454207962.png)

基本操作过多....

## 5.4 二叉树的性质和存储结构

### 5.4.1 二叉树的性质

**二叉树具有下列重要特性：**

- 性质1: 在二叉树的第`i`层上至多有`2^(i-1)` 个结点（`i >= 1`)。

- 性质2: 深度为k的二叉树至多有`2^k-1` 个结点(`k >= 1`)。

- 性质3: 对任何一棵二叉树T, 如果其终端结点数为n0, 度为2的结点数为`n2`, 则`n0 = n2+1`.

  ![1676465305117](DataStructure3.assets/1676465305117.png)

- **两种特殊二叉树**

  为什么要研究满二叉树, 完全二叉树, 因为它们在顺序存储方式下可以复原.

  - **满二叉树**

    一棵深度为k且有`2^k-1`个结点的二叉树称为满二叉树. 

    特点: 1. 每一层上的结点数都是最大结点数. 每一层都是满的

    2. 叶子结点全部在最底层.

    对满二叉树节点位置进行变编号

    1. 编号规则: 从根节点开始, 自上而下, 自左到右.

    2. 每个节点位置都有元素.

       ![1676467097235](DataStructure3.assets/1676467097235.png)

    满二叉树在同样深度的二叉树中, 结点数是最多的.

    满二叉树在同样深度的二叉树中, 叶子结点个数最多.

  - **完全二叉树**

    深度为k的, 有n个结点的二叉树, 当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时， 称之为完全二叉树。

    > 编号编的跟满二叉树一样, 但不是满二叉树. 

    ![1676468126788](DataStructure3.assets/1676468126788.png)

    从满二叉树的最后一个结点开始(从由往左), 连续去掉任意个结点, 即是一个完全二叉树.  一定是连续去掉.

    下面这个就不是完全二叉树.

    ![1676468478006](DataStructure3.assets/1676468478006.png)

    完全二叉树的特点是：
    (1) 叶子结点只可能在层次最大的两层上出现；(叶子只能在最后两层.)
    (2) 对任一结点, 若其右分支下的子孙的最大层次为`l`, 则其左分支下的子孙的最大层次必为`l `或`l+1`( 因为这样就不是满二叉树的编号法了, 就不是完全二叉树了.)

- ![1676469459295](DataStructure3.assets/1676469459295.png)

  知道完全二叉树的结点数, 就可以知道这个完全二叉树的深度了.

- ![1676469797835](DataStructure3.assets/1676469797835.png)

  ![1676469924364](DataStructure3.assets/1676469924364.png)

  ![1676470106910](DataStructure3.assets/1676470106910.png)

### 5.4.2 二叉树的存储结构

二叉树的存储结构也可采用顺序存储和链式存储两种方式。

- 顺序存储结构

  实现: 按照满二叉树的结点层次编号, 依次存放二叉树中的数据元素. 对n个结点的二叉树.

  顺序存储结构使用一组地址连续的存储单元来存储数据元素，为了能够在存储结构中反映出结点之间的逻辑关系，必须将二叉树中的结点依照一定的规律安排在这组单元中。

  对于完全二叉树, 只要从根起按层序存储即可, 依次自上而下, 自左至右存储结点元素, 即将完全二叉树上编号为`i`的结点元素存储在如上定义的一维数组中下标为`i-1`的分量中。

  ![1676470782091](DataStructure3.assets/1676470782091.png)

  ```c
  //-----二叉树的顺序存储表示－－－－－
  #define MAXTSIZE 100
  typedef TElemType SqBiTree[MAXTSIZE]; //二叉树的最大结点数
  SqBiTree bt;    //0号单元存储根结点
  ```

  那如果不是完全二叉树呢?

  对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中.

  ![1676471433036](DataStructure3.assets/1676471433036.png)

  空着的, 用0填充. 其实还是满二叉树的编号法.

由此可见, 这种顺序存储结构仅适用于完全二叉树. 因为, 在最坏的情况下, 一个深度为k且只有k个结点的`单支树`(树中不存在度为2的结点)却需要长度为`2^k-1`的一维数组. 这造成了存储空间的极大浪费, 所以对于一般二叉树, 更适合采取下面的链式存储结构.

![1676472337699](DataStructure3.assets/1676472337699.png)

- 链式存储结构

  二叉树的结点由一个数据元素和分别指向其左、右子树的两个分支构成，则表示二叉树的链表中的结点至少包含3个域: 数据域和左, 右指针域. 有时, 为了便于找到结点的双亲, 还可在结点结构中增加一个指向其双亲结点的指针域.

  利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表.

  ![1676472953116](DataStructure3.assets/1676472953116.png)

  ![1676472972853](DataStructure3.assets/1676472972853.png)

  ```c
  //-----二叉树的二叉链表存储表示－－－－－
  typedef struct BiTNode{
  	TElemType data;          //结点数据域
  	struct BiTNode *lchild, *rchild;   //左右孩子指针
  } BiTNode, *BiTree;
  ```

  n个结点一共2n个链(指针)域. 除了根节点, 其他每个结点有且仅有一个双亲, 所以只有n-1的结点的链域存放指针, 指向非空孩子结点. 那空指针数 = 2n- (n-1) = n+1.

  ```c
  //-----三叉树的二叉链表存储表示－－－－－
  typedef struct TriTNode{
  	TElemType data;          //结点数据域
  	struct TriTNode *lchild,*parent,*rchild;   //左右孩子指针 跟双亲指针
  } TriTNode, *TriTree;
  ```

## 5.5 遍历二叉树和线索二叉树


# 第5章 树和二叉树

![1676448529917](DataStructure3.assets/1676448529917.png)

![1676448583848](DataStructure3.assets/1676448583848.png)

## 5.1 树和二叉树的定义

### 5.1.1 树的定义

树(Tree)是n(n>=0)个结点的有限集, 它或为空树(n= 0); 或为非空树，对于非空树T:

(1) 有且仅有一个称之为根的结点；
(2) 除根结点以外的其余结点可分为m(m>0)个互不相交的有限集T1, T2 , …, Tm, 其中每一个集合本身又是一棵树， 并且称为根的子树(SubTree)。

![1676449829436](DataStructure3.assets/1676449829436.png)

树的结构定义是一个递归的定义，即在树的定义中又用到树的定义，它道出了**树的固有特性**。

### 5.1.2 树的基本术语

(1) `结点`：树中的一个`独立单元`。包含一个`数据元素`及`若干指向其子树的分支`，如图5.1(b) 中的A , B, C, D等. (下面术语中均以图5.1 (b) 为例来说明). 根节点: 非空树中没有前驱结点的结点.

(2)`结点的度`：结点拥有的`子树数`称为结点的度。例如，A的度为3, C的度为1, F的度为0。

(3)`树的度`： 树的度是`树内各结点度的最大值`。图5.1 (b) 所示的树的度为3。

(4) `叶子`：`度为0的结点`称为叶子或`终端结点`。结点K 、L 、F 、G 、M 、I 、J都是树的叶子。

(5)` 非终端结点`：`度不为0的结点`称为非终端结点或`分支结点`。`除根结点之外`，非终端结点也称为`内部结点`。

(6)`双亲和孩子`：`结点的子树的根`称为该结点的孩子，相应地，该`结点称为孩子的双亲`。例如，B的双亲为A, B的孩子有E和F。

(7) `兄弟`：`同一个双亲的孩子之间`互称兄弟。例如，H 、I 和J互为兄弟。

(8) `祖先`：`从根到该结点所经分支上的所有结点`。例如， M 的祖先为A 、D 和H。

(9) `子孙`：`以某结点为根`的`子树中的任一结点`都称为该结点的子孙。如B的子孙为E 、K 、L和F。

(10) `层次`：结点的层次从根开始定义起，根为第一层，根的孩子为第二层。树中任一结点的层次等于其双亲结点的层次加1。

(11)`堂兄弟`：`双亲在同一层的结点`互为堂兄弟。例如，结点G 与E 、F、H 、I 、J互为堂兄弟。

(12)`树的深度`：`树中结点的最大层次`称为树的深度或高度。图5.1 (b)所示的树的深度为4。

(13)`有序树和无序树`：如果将树中结点的各子树看成从左至右是有次序的(即不能互换), 则称该树为有序树, 否则称为无序树。在有序树中最左边的子树的根称为第一个孩子，最右边的称为最后一个孩子.

(14)`森林`：是m (m>=0)棵互不相交的树的集合。对树中每个结点而言，其子树的集合即为森林。由此，也可以用森林和树相互递归的定义来描述树。B,C,D 为根的树, 组成一个森林.
![1676451948491](DataStructure3.assets/1676451948491.png)

![1676451728603](DataStructure3.assets/1676451728603.png)

![1676451980616](DataStructure3.assets/1676451980616.png)

### 5.1.3 二叉树的定义

![1676452301070](DataStructure3.assets/1676452301070.png)

- 定义:

二叉树(Binary Tree)是n(n>=0)个结点所构成的有限集合, 它或为空树(n= 0); 或为非空树, 对于非空树T:

(1) 有且仅有一个称之为根的结点；
(2) 除根结点以外的其余结点分为两个互不相交的子集T1和T2, 分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。

二叉树与树一样具有递归性质，二叉树与树的区别主要有以下两点：
(1) 二叉树每个结点至多只有两棵子树或两个孩子 (即二叉树中不存在度大于2 的结点)；
(2) 二叉树的子树有左右之分, 其次序不能任意颠倒。

二叉树的递归定义表明二叉树或为空，或是由一个根结点加上两棵分别称为左子树和右子树的、互不相交的二叉树组成。由于这两棵子树也是二叉树，则由二叉树的定义，它们也可以是空树。

注意:

- 二叉树不是树的特殊情况, 它们是两个不同的东西.
- 二叉树结点的子树, 要区分左子树与右子树, 即使只有一棵树, 也必须要区分, 说明它是左子树还是右子树.
- 树中当结点只有一个孩子时, 就不必区分左右的次序问题. 这也是树与二叉树的主要区别.

![1676453064493](DataStructure3.assets/1676453064493.png)

![1676453142558](DataStructure3.assets/1676453142558.png)

![1676453173227](DataStructure3.assets/1676453173227.png)

## 5.2 案例引入

随着大数据时代的到来， 如何采用有效的数据压缩技术， 来节省数据文件的存储空间和网络传输时间越来越引起人们的重视。

案例5.1: 数据压缩问题。

![1676453394064](DataStructure3.assets/1676453394064.png)

案例5.2: 利用二叉树求解表达式的值。

![1676453403264](DataStructure3.assets/1676453403264.png)

## 5.3 树和二叉树的抽象数据类型定义

- 树的ADT

![1676453830979](DataStructure3.assets/1676453830979.png)

![1676453873780](DataStructure3.assets/1676453873780.png)

![1676453890017](DataStructure3.assets/1676453890017.png)

- 二叉树的ADT

> 二叉树是非常重要的一个数据结构, 跟前面链表, 顺序, 数组一样重要.

![1676454197075](DataStructure3.assets/1676454197075.png)
![1676454207962](DataStructure3.assets/1676454207962.png)

基本操作过多....

## 5.4 二叉树的性质和存储结构

### 5.4.1 二叉树的性质

**二叉树具有下列重要特性：**

- 性质1: 在二叉树的第`i`层上至多有`2^(i-1)` 个结点（`i >= 1`)。

- 性质2: 深度为k的二叉树至多有`2^k-1` 个结点(`k >= 1`)。

- 性质3: 对任何一棵二叉树T, 如果其终端结点数为n0, 度为2的结点数为`n2`, 则`n0 = n2+1`.

  ![1676465305117](DataStructure3.assets/1676465305117.png)

- **两种特殊二叉树**

  为什么要研究满二叉树, 完全二叉树, 因为它们在顺序存储方式下可以复原.

  - **满二叉树**

    一棵深度为k且有`2^k-1`个结点的二叉树称为满二叉树. 

    特点: 1. 每一层上的结点数都是最大结点数. 每一层都是满的

    2. 叶子结点全部在最底层.

    对满二叉树节点位置进行变编号

    1. 编号规则: 从根节点开始, 自上而下, 自左到右.

    2. 每个节点位置都有元素.

       ![1676467097235](DataStructure3.assets/1676467097235.png)

    满二叉树在同样深度的二叉树中, 结点数是最多的.

    满二叉树在同样深度的二叉树中, 叶子结点个数最多.

  - **完全二叉树**

    深度为k的, 有n个结点的二叉树, 当且仅当其每一个结点都与深度为k的满二叉树中编号从1至n的结点一一对应时， 称之为完全二叉树。

    > 编号编的跟满二叉树一样, 但不是满二叉树. 

    ![1676468126788](DataStructure3.assets/1676468126788.png)

    从满二叉树的最后一个结点开始(从由往左), 连续去掉任意个结点, 即是一个完全二叉树.  一定是连续去掉.

    下面这个就不是完全二叉树.

    ![1676468478006](DataStructure3.assets/1676468478006.png)

    完全二叉树的特点是：
    (1) 叶子结点只可能在层次最大的两层上出现；(叶子只能在最后两层.)
    (2) 对任一结点, 若其右分支下的子孙的最大层次为`l`, 则其左分支下的子孙的最大层次必为`l `或`l+1`( 因为这样就不是满二叉树的编号法了, 就不是完全二叉树了.)

- ![1676469459295](DataStructure3.assets/1676469459295.png)

  知道完全二叉树的结点数, 就可以知道这个完全二叉树的深度了.

- ![1676469797835](DataStructure3.assets/1676469797835.png)

  ![1676469924364](DataStructure3.assets/1676469924364.png)

  ![1676470106910](DataStructure3.assets/1676470106910.png)

### 5.4.2 二叉树的存储结构

二叉树的存储结构也可采用顺序存储和链式存储两种方式。

- 顺序存储结构

  实现: 按照满二叉树的结点层次编号, 依次存放二叉树中的数据元素. 对n个结点的二叉树.

  顺序存储结构使用一组地址连续的存储单元来存储数据元素，为了能够在存储结构中反映出结点之间的逻辑关系，必须将二叉树中的结点依照一定的规律安排在这组单元中。

  对于完全二叉树, 只要从根起按层序存储即可, 依次自上而下, 自左至右存储结点元素, 即将完全二叉树上编号为`i`的结点元素存储在如上定义的一维数组中下标为`i-1`的分量中。

  ![1676470782091](DataStructure3.assets/1676470782091.png)

  ```c
  //-----二叉树的顺序存储表示－－－－－
  #define MAXTSIZE 100
  typedef TElemType SqBiTree[MAXTSIZE]; //二叉树的最大结点数
  SqBiTree bt;    //0号单元存储根结点
  ```

  那如果不是完全二叉树呢?

  对于一般二叉树，则应将其每个结点与完全二叉树上的结点相对照，存储在一维数组的相应分量中.

  ![1676471433036](DataStructure3.assets/1676471433036.png)

  空着的, 用0填充. 其实还是满二叉树的编号法.

由此可见, 这种顺序存储结构仅适用于完全二叉树. 因为, 在最坏的情况下, 一个深度为k且只有k个结点的`单支树`(树中不存在度为2的结点)却需要长度为`2^k-1`的一维数组. 这造成了存储空间的极大浪费, 所以对于一般二叉树, 更适合采取下面的链式存储结构.

![1676472337699](DataStructure3.assets/1676472337699.png)

- 链式存储结构

  二叉树的结点由一个数据元素和分别指向其左、右子树的两个分支构成，则表示二叉树的链表中的结点至少包含3个域: 数据域和左, 右指针域. 有时, 为了便于找到结点的双亲, 还可在结点结构中增加一个指向其双亲结点的指针域.

  利用这两种结点结构所得二叉树的存储结构分别称之为二叉链表和三叉链表.

  ![1676472953116](DataStructure3.assets/1676472953116.png)

  ![1676472972853](DataStructure3.assets/1676472972853.png)

  ```c
  //-----二叉树的二叉链表存储表示－－－－－
  typedef struct BiTNode{
  	TElemType data;          //结点数据域
  	struct BiTNode *lchild, *rchild;   //左右孩子指针
  } BiTNode, *BiTree;
  ```

  n个结点一共2n个链(指针)域. 除了根节点, 其他每个结点有且仅有一个双亲, 所以只有n-1的结点的链域存放指针, 指向非空孩子结点. 那空指针数 = 2n- (n-1) = n+1.

  ```c
  //-----三叉树的二叉链表存储表示－－－－－
  typedef struct TriTNode{
  	TElemType data;          //结点数据域
  	struct TriTNode *lchild,*parent,*rchild;   //左右孩子指针 跟双亲指针
  } TriTNode, *TriTree;
  ```

## 5.5 遍历二叉树和线索二叉树

在二叉树的一些应用中，常常要求在树中查找具有某种特征的结点，或者是对树中的全部结点逐一进行处理，这就提出了一个遍历二叉树的问题。线索二叉树是在第一次遍历时将结点的前驱、后继信息存储下来，便于再次遍历二叉树。

### 5.5.1 遍历二叉树

遍历二叉树(traversing binary tree)是指按某条搜索路径巡访树中每个结点, 使得每个结点均被访问一次, 而且仅被访问一次.

> 访间的含义很广，可以是对结点做各种处理，包括输出结点的信息，对结点进行运算和修改等。 但不能破坏原数据结构.

遍历的目的是, 得到树中所有结点的一个线性排列.

遍历用途, 它是树结构 增删改查和排序的前提. 是二叉树一切运算的基础与核心.

> 遍历二叉树是二叉树最基本的操作，也是二叉树其他各种操作的基础，遍历的实质是对二叉树进行线性化的过程，即遍历的结果是将非线性结构的树中结点排成一个线性序列。
>
> 由于二叉树的每个结点都可能有两棵子树，因而需要寻找一种规律，以便使二叉树上的结点能排列在一个线性队列上，从而便于遍历。

二叉树是由3个基本单元组成：根结点、左子树和右子树. 若能依次遍历这三部分，便是遍历了整个二叉树。

假如从L、D、R 分别表示遍历左子树、访问根结点和遍历右子树，则可有DLR、LDR 、L RD、DRL、RDL、RLD这6种遍历二叉树的方案。

若限定`先左后右`，则只有前3种情况，分别称之为`先(根)序遍历`、`中(根)序遍历`和`后(根)序遍历`.

![1676529045507](DataStructure3.assets/1676529045507.png)

先序遍历二叉树的操作定义如下：

- 先序遍历

![1676529455176](DataStructure3.assets/1676529455176.png)

- 中序遍历

  ![1676530046333](DataStructure3.assets/1676530046333.png)

- 后序遍历

  ![1676530143126](DataStructure3.assets/1676530143126.png)

练习一下:

![1676530592592](DataStructure3.assets/1676530592592.png)

![1676530755518](DataStructure3.assets/1676530755518.png)

- > **根据遍历序列确定二叉树**

  若二叉树中各结点的值均不相同，任意一棵二叉树结点的先序序列、中序序列和后序序列都是唯一的。

  由二叉树的先序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树。

  例子:  先序+中序

  ![1676532938701](DataStructure3.assets/1676532938701.png)

  先序可以初步确定, A是根, B是A的左子树的根. 中序的CDB可以确定, C是B的左子树的根, D是C的右孩子.

  先序ABCDEF + 中序CDBFEA 可以确定, E是B的右子树的根, F是E的左孩子. A的左子树结束.

  先序的GHIJ 跟中序的IHGJ 可以确定, G是A的右子树的根,  J是G的右孩子, H是G的左子树的根, I是H的左孩子.

  ![1676533456481](DataStructure3.assets/1676533456481.png)

  中序+后序

  ![1676533680060](DataStructure3.assets/1676533680060.png)

> 先序跟后序没法确定根.

- 遍历的算法实现  先序遍历

  ![1676534441415](DataStructure3.assets/1676534441415.png)

  ```c
  int PreOrderTraverse(BiTree T)   //递归算法.
  {
      if(NULL == T) return 0; //空了
      else
      {
          visit(T);  //访问根节点 比如printf(T->data);访问函数, 具体根据需求写
          PreOrderTraverse(T->lchild); //递归遍历左子树
          PreOrderTraverse(T->rchild);  //递归遍历右子树
      }
  }
  ```

  ![1676535007454](DataStructure3.assets/1676535007454.png)

- 遍历的算法实现  中序遍历

  ![1676535357020](DataStructure3.assets/1676535357020.png)

  ```c
  int InOrderTraverse(BiTree T)   //递归算法.
  {
      if(NULL == T) return 0; //空了
      else
      {
          InOrderTraverse(T->lchild); //递归遍历左子树
          visit(T);  //访问根节点 比如printf(T->data); 访问函数, 具体根据需求写
          InOrderTraverse(T->rchild);  //递归遍历右子树
      }
  }
  ```

- 遍历的算法实现  中序遍历

  ```c
  int PostOrderTraverse(BiTree T)   //递归算法.
  {
      if(NULL == T) return 0; //空了
      else
      {
          PostOrderTraverse(T->lchild); //递归遍历左子树       
          PostOrderTraverse(T->rchild);  //递归遍历右子树
          visit(T);  //访问根节点 比如printf(T->data); 访问函数, 具体根据需求写
      }
  }
  ```

- 遍历算法分析

  从递归执行过程的角度来看先序、中序和后序遍历也是完全相同的。递归调用 , 每次新入调用的时候 ,都要开辟新的栈帧, 对于栈空间的开销, 以及时间上的开销是比较大的.
  时间复杂度, 跟空间复杂度都是O(n).

  前面讲递归的时候, 说到可利用栈将递归算法改写成非递归算法.

  例如, 
  从中序遍历递归算法执行过程中递归工作栈的状态可见：
  (1) 工作记录中包含两项, 其一是递归调用的语句编号, 其二是指向根结点的指针, 则当栈顶记录中的指针非空时, 应遍历左子树, 即指向左子树根的指针进栈;

  (2) 若栈顶记录中的指针值为空, 则应退至上一层, 若是从左子树返回, 则应访问当前层(即栈顶记录)中指针所指的根结点;

  (3) 若是从右子树返回, 则表明当前层的遍历结束, 应继续退栈. 从另一个角度看, 这意味着遍历右子树时不再需要保存当前层的根指针, 直接修改栈顶记录中的指针即可.

- 遍历二叉树的非递归算法

  算法5.2 中序遍历的非递归算法

  基本思想: 

  1 先建立一个栈

  2 根节点入栈, 遍历左子树

  3 根节点出栈, 输出根节点, 遍历右子树

  【算法步骤】
  1 初始化一个空栈s, 指针p指向根结点。
  2 申请一个结点空间q, 用来存放栈顶弹出的元素。
  3 当p非空或者栈S非空时，循环执行以下操作：
  	如果p非空，则将p进栈，p指向该结点的左孩子；
  	如果p为空，则弹出栈顶元素并访间，将p指向该结点的右孩子。

  ```c
  void InOrderTraverse(BiTree T)
  {
      BiTree p = T;
      InitStack(S);
      BiTNode *q = malloc(sizeof(BiTNode));
      BiTNode *ff = q;
      while(p || !StackEmepy(S)) //p不为NULL 或者Stack里不是空的.
      {
          if(P)  //非NULL
          {
              Push(S,p); //根指针进栈
              p = p->lchild; //遍历左子树
          }
          else
          {
              Pop(S,q); //出栈 把值写进malloc的内存空间.
              printf("%c", q->data); //访问根结点
              p = q->rchild; //遍历右子树
          }
      }
      free(ff);
  }
  ```

- > **二叉树的层次遍历**

  按层次遍历二叉树的方式, 这种方式按照"从上到下, 从左到右"的顺序遍历二叉树, 即先遍历二叉树第一层的结点, 然后是第二层的结点, 直到最底层的结点, 对每一层的遍历按照从左到右的次序进行.

  算法设计思路:

  用队列.

  - 先将根结点进队,

  - 队不空时循环: 从队列中出队一个结点*p, 访问它.

    若它有左孩子结点, 将左孩子结点进队;

    若有右孩子结点, 将右孩子结点进队.

    > 就相当于, 先让一个结点入队, 比如是根节点, 然后队头元素根节点出队, 顺便把根节点的左右孩子结点入队. 然后每个结点出队的时候, 把它自己的孩子入队.

  ```c
  typedef struct{
      BTNode data[MAXSIZE]; //循环队列少用一个位置
      int front, rear;
  }SqQueue;
  //代码错的, 意思明白就行.
  void LevelOrder(BiTNode *b)
  {
      BTNode *p;
      SqQueue *qu;
      InitQueue(qu);  //初始化队列
      enQueue(qu, b);  //根节点入队
      while(!QueueEmpty(qu))   //队列不空时
      {
          deQueue(qu,p);   //出队
          printf("%c", p->data); //访问p
          if( p->lchild ) enQueue(qu, p->lchild); //左孩子不是NULL, 入队
          if( p->rchild ) enQueue(qu, p->rchild); //右孩子不是NULL, 入队
      }
  }
  ```

- > 二叉树遍历算法的应用 之二叉树的建立

  **算法5.3 先序遍历的顺序建立二叉链表**

  ![1676621211395](DataStructure3.assets/1676621211395.png)

  只有一个先序序列的话, 是没有办法确定唯一的二叉树的. 所以需要添加空位.

  上面两课二叉树, 左边的就是: ABC##DE#G##F###

  【算法步骤】
  (1) 扫描字符序列, 读入字符ch。
  (2) 如果ch是一个"#" 字符,  则表明该二叉树为空树， 即T为NULL; 否则执行以下操作：
  • 申请一个结点空间T;
  • 将ch赋给T-> data;
  • 递归创建T的左子树；
  • 递归创建T的右子树；

  ```c
  //-----二叉树的二叉链表存储表示－－－－－
  typedef struct BiTNode{    
      TElemType data;          //结点数据域    
      struct BiTNode *lchild, *rchild;   //左右孩子指针
  } BiTNode, *BiTree;
  
  int CreateBiTree(BiTree *T) //二级指针, 因为要改实参指针的值
  {
      scanf(&ch); //表示输入个值.别计较具体语法
      if(ch == '#') *T = NULL;  //递归结束, 建空树
      else  //递归创建二叉树
      {
          *T = malloc(sizeof(BiTNode));  //创建根结点
          if(!*T)  exit(OVERFLOW);
          *T->data = ch;          //根节点数据域赋值
          CreateBiTree(&((*T)->lchild)); //给左孩子指针的地址,递归创建左子树
          CreateBiTree(&((*T)->rchild));
      }
      return 0;
  }
  ```

  **算法5.4 复制二叉树**

  复制二叉树就是利用巳有的一棵二叉树复制得到另外一棵与其完全相同的二叉树。根据二叉树的特点， 复制步骤如下：若二叉树不空， 则首先复制根结点， 这相当于二叉树先序遍历算法中访问根结点的语句；然后分别复制二叉树根结点的左子树和右子树， 这相当千先序遍历中递归遍历左子树和右子树的语句。因此， 复制函数的实现与二叉树先序遍历的实现非常类似。

  【算法步骤】
  如果是空树， 递归结束， 否则执行以下操作：
  • 申请一个新结点空间， 复制根结点；
  • 递归复制左子树；
  • 递归复制右子树。

  ```c
  int Copy(BiTree T, BiTree *NewT)
  {
      if( !T ) 
      {
          *NewT = NULL;
          return 0;
      }
      else
      {
          *NewT = malloc( sizeof(BiTNode) ); 
          (*NewT)->data = T->data;
          Copy( T->lchild, &((*NewT)->lchild) );
          Copy( T->rchild, &((*NewT)->rchild) );
      }
      return 1;
  }
  ```

  > 一般, 在嵌入式系统里, 递归要考量一下的. 因为栈空间比较紧张.


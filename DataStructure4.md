

# 第6章 图

![1677475108488](DataStructure4.assets/1677475108488.png)
图是一种比线性表和树更为复杂的数据结构。
在线性表中，数据元素之间仅有线性关系，每个数据元素只有一个直接前驱和一个直接后继；
在树形结构中，数据元素之间有着明显的层次关系，并且每一层中的数据元素可能和下一层中的多个元素(即其孩子结点)相关，但只能和上一层中一个元素(即其双亲结点)相关；
而在图结构中，结点之间的关系可以是任意的，图中任意两个数据元素之间都可能相关。

在离散数学中，图论是专门研究图的性质的数学分支，而在数据结构中，则应用图论的知识讨论如何在计算机上实现图的操作，因此主要学习图的存储结构，以及若于图的操作的实现。

## 6.1 图的定义和基本术语

### 6.1.1 图的定义和基本术语

图(Graph) G由两个集合V(Vertex)和E(Edge)组成，记为G=(V,E) , 其中V是顶点(数据元素)的`有穷非空集合`，E是边的`有穷集合`。V(G)和E(G)通常分别表示图G的顶点集合和边集合，E(G)可以为空集。若E(G)为空，则图G只有顶点而没有边。	

对于图G, 若边集E(G)为有向边的集合，则称该图为有向图；若边集E(G)为无向边的集合，则称该图为无向图。

在有向图中，顶点对`<x, y>`是有序的，它称为从`顶点x到顶点y`的一条有向边。因此`<x,y>与<y, x>`是不同的两条边。顶点对用一对尖括号括起来，x是有向边的`始点`，y是有向边的`终点`。<x, y>也称作一条`弧`，则x为`弧尾`， y为`弧头`。

在无向图中, 顶点对(x, y)是`无序`的, 它`称为`与顶点x和顶点y相关联的一条`边`. 这条边没有特定的方向, `(x,y)与 (y,x)`是同一条边. 为了有区别于有向图, 无向图的顶点对用一对圆括号括起来.
![1677484167382](DataStructure4.assets/1677484167382.png)

- 相关概念

`完全图`: 任意两个顶点都有一条边相连.
`无向完全图和有向完全图`: 对于无向图， 若具有`n(n-1)/2 `条边，则称为无向完全图。
对于有向图， 若具有`n(n-1)`条弧，则称为有向完全图。
![1677484424320](DataStructure4.assets/1677484424320.png)

`稀疏图和稠密图`：有很少条边或弧(如e<nlog~2~n) 的图称为`稀疏图`, 反之称为`稠密图`。

`权和网`：在实际应用中,每条边可以标上`具有某种含义的数值`, 该数值称为该边上的`权`. 这些权可以表示从一个顶点到另一个顶点的`距离`或`耗费`. 这种带权的图通常称为`网`. 

`邻接`: 有`边/弧相连的两个顶点`之间的关系. 存在边(Vi,Vj), 则称Vi和Vj互为邻接点. 存在<Vi,Vj>则称Vi邻接到Vj, Vj邻接于Vi.

`关联(依附)` : `边/弧与顶点之间`的关系. 存在(Vi,Vj)/<Vi,Vj>, 则称该边/弧关联(依附)于Vi和Vj.
`顶点的度, 入度与出度`: 顶点v 的度为TD(v) = ID(v) + OD(v).
![1677489380661](DataStructure4.assets/1677489380661.png)

`有向树`: 有一个顶点的入度为0, 其余顶点的入度均为1的有向图称为有向树。
![1677489454423](DataStructure4.assets/1677489454423.png)

`路径`: `接续`的 边 构成的`顶点序列`. V1,V3,V4 这个路径就是2条边, 三个顶点

`路径长度`: 路径上 `边或弧的数目/权值之和`.

`回路`或`环`：第一个顶点和最后一个顶点相同的路径称为回路或环。

`简单路径`: 序列中顶点不重复出现的路径称为简单路径. 路径起点和终点是可以相同的.

`简单回路`或`简单环`: 除了第一个顶点和最后一个顶点之外, 其余顶点不重复出现的回路, 称为简单回路或简单环.
![1677491338131](DataStructure4.assets/1677491338131.png)

`连通`,`连通图`：在无向图G 中, 如果从顶点`v`到顶点`v'有路径`, 则称`v` 和`v'`是连通的. 如果对于图中`任意两个`顶点`Vi, Vj`, `Vi 和Vj `都是连通的, 则称G是连通图.  

`强连通图`: 在有向图G中, 如果对于图中每一对`Vi,Vj`, `Vi不等于Vj`, 从`Vi到Vj` 和`从Vj到Vi`都存在`路径`, 则称G是强连通图。
![1677491902273](DataStructure4.assets/1677491902273.png)

`子图`:
![1677492088334](DataStructure4.assets/1677492088334.png)

`连通分量`和`强连通分量`: 所谓连通分量, 指的是`无向图`中的极大连通子图. 有`向图中`的极大强连通子图称作有向图的强连通分量。
![1677492260884](DataStructure4.assets/1677492260884.png)
![1677492440999](DataStructure4.assets/1677492440999.png)

`极小连通子图` : 该子图是G的连通子图, 在该子图中删除任何一条边, 该子图不再连通.

连通图的`生成树`： 一个`极小连通子图`,它`含有图中全部顶点`, 但只有足以构成一棵树的`n-1`条边, 这样的连通子图称为连通图的生成树.

> 一棵有n个顶点的`生成树`有且仅有n-1条边。如果一个图有n个顶点和小于n-1条边，则是非连通图。如果它多于`n-1`条边, 则一定有环. 但是, 有`n-1`条边的图不一定是生成树。

`生成森林`: 一个有向图的生成森林是由若干棵有向树组成, 含有图中全部顶点, 但只有足以构成若干棵不相交的有向树的弧。

![1677493380531](DataStructure4.assets/1677493380531.png)

## 6.2 案例引入

案例6.1: 六度空间理论

六度空间理论是一个数学领域的猜想, 又称为六度分割理论(Six Degrees of Separation). 六度空间理论是20 世纪60 年代由美国的心理学家米格兰姆(Stanley Milgram) 提出的, 理论指出: 你和任何一个陌生人之间所间隔的人不会超过6个, 也就是说, 最多通过6个中间人你就能够认识任何一个陌生人.
![1677505411573](DataStructure4.assets/1677505411573.png)

## 6.3 图的类型定义

图是一种数据结构，加上一组基本操作，就构成了抽象数据类型。抽象数据类型图的定义如下：
![1677505676315](DataStructure4.assets/1677505676315.png)

基本操作：
**CreateGraph(&G, V, VR)**
初始条件：V是图的顶点集，VR是图中弧的集合。
操作结果：按V和VR的定义构造图G。
DestroyGraph (&G)
初始条件：图G存在。
操作结果：销毁图G。
LocateVex(G,u)
初始条件：图G存在，u和G中顶点有相同特征。
操作结果：若G中存在顶点u, 则返回该顶点在图中的位置；否则返回其他信息。
GetVex(G,v)
初始条件：图G存在，v是G中某个顶点。
操作结果：返回v的值。
PutVex(&G,v,value);
初始条件：图G存在，v是G中某个顶点。
操作结果：对v赋值value。
FirstAdjVex(G,v);
初始条件：图G存在，v是G中某个顶点。
操作结果：返回v的第一个邻接顶点。若v在G中没有邻接顶点，则返回“空” 。
NextAdjVex(G,v,w);
初始条件：图G存在，v是G中某个顶点，w是v的邻接顶点。
操作结果：返回v的（相对千w的）下一个邻接顶点。若w是v的最后一个邻接点，则返回“空” 。
InsertVex(&G,v)
初始条件：图G存在，v和图中顶点有相同特征。
操作结果：在图G中增添新顶点v。
DeleteVex(&G,v)
初始条件：图G存在，v是G中某个顶点。
操作结果：删除G中顶点v及其相关的弧。
InsertArc(&G,v,w)
初始条件：图G存在，v和w是G中两个顶点。
操作结果：在G中增添弧<v, w>, 若G是无向图，则还增添对称弧<w, v>。
Dele七eArc(&G,v,w)
初始条件：图G存在，v和w是G中两个顶点。
操作结果：在G中删除弧<v, w>, 若G是无向图，则还删除对称弧<w, v>。
**DFSTraverse(G)**
初始条件：图G存在。
操作结果：对图进行**深度优先遍历**，在遍历过程中对每个顶点访问一次。
**BFSTraverse(G)**
初始条件：图G存在。
操作结果：对图进行**广度优先遍历**，在遍历过程中对每个顶点访问一次。

## 6.4 图的存储结构

> 由于图的结构比较复杂, 任意两个顶点之间都可能存在联系, 因此无法以数据元素在存储区中的物理位置来表示元素之间的关系, 即图没有顺序存储结构, 但可以借助`二维数组来表示元素之间的关系`, 即`邻接矩阵表示法`。另一方面, 由于图的任意两个顶点间都可能存在关系, 因此, 用`链式存储`表示图是很自然的事, 图的链式存储有多种, 有`邻接表,` `十字链表`和`邻接多重表`, 应根据实际需要的不同选择不同的存储结构.

![1677506368545](DataStructure4.assets/1677506368545.png)

### 6.4.1 邻接矩阵

1. **邻接矩阵表示法**

   邻接矩阵(Adjacency Matrix)是表示顶点之间相邻关系的矩阵.设G(V, E)是具有n个顶点的图, 则G的邻接矩阵是具有如下性质的n阶方阵:
   ![1677506486125](DataStructure4.assets/1677506486125.png)

   ![1677506729727](DataStructure4.assets/1677506729727.png)

   - **举个栗子:**

   ![1677559486050](DataStructure4.assets/1677559486050.png)

   ![1677571434395](DataStructure4.assets/1677571434395.png)

   > 有向图邻接矩阵, 用二维数组的话, 就是1维下标指向2维下边

   分析1: 有向图的邻接矩阵可能是`不对称的`.

   分析2: 顶点的出度= `第i行`元素之和

   ​	    顶点的入度= `第i列`元素之和

   ​	    顶点的度 =  `第i行`元素之和 + `第i列`元素之和

2. **网的邻接矩阵表示法**

   ![1677571974759](DataStructure4.assets/1677571974759.png)

3. **邻接矩阵的存储表示**

   用邻接矩阵表示法表示图, 除了一个用来存储邻接矩阵的二维数组外, 还需要用一个一维数组来存储顶点信息.

   ```c
   //-----图的邻接矩阵存储表示－－－－－
   #define MaxInt  32767    //表示无穷大值, 即∞
   #define MVNum 100       //顶点最大数
   
   typedef char VerTexType; //假设顶点的数据类型为字符型
   typedef int ArcType;   //假设边的权值类型为整型
   
   typedef struct {
       VerTexType vexs[MVNum]; //顶点表
       ArcType arcs[MVNum][MVNum];  //邻接矩阵
       int vexnum, arcnum;  //图的当前点数和边数
   } AMGraph; //Adjacency Matrix Graph
   ```

4. **采用邻接矩阵表示法创建无向网**

   算法6.1 采用邻接矩阵表示法创建无向网

   【算法步骤】：

   1. 输入总顶点数和总边数。
   2. 依次输入点的信息存入顶点表中。
   3. 初始化邻接矩阵， 使每个权值初始化为极大值。
   4. 构造邻接矩阵。依次输入每条边依附的顶点和其权值，确定两个顶点在图中的位置之后，使相应边赋予相应的权值，同时使其对称边赋予相同的权值。

   ```c
   /*创建邻接矩阵图
     参数 AMGraph *G 指针类型, 把变量AMGraph G地址传进来.
     返回状态值.
   */
   int CreateUDN(AMGraph *G)
   {    //采用邻接矩阵表示法，创建无向网G
       scanf("%d %d", &G->vexnum, &G->arcnum); //输入总顶点和总边数
       for(int i = 0; i < G->vexnum; i++)
           scanf("%c", &(G->vexs[i]));  //依次输入顶点的信息
       for(int i = O; i < G->vexnum; ++i)
   		for (int j =0; j < G->vexnum; ++j)
   			G->arcs[i][j]= MaxInt;  //初始化成极大值 无向图的话 =0
       for(int k = 0; k < G->arcnum; k++)
       {
           VerTexType v1, v2;  //两个顶点
           ArcType w;  //两个顶点的边的权
           scanf("%c %c %d", &v1, &v2, &w); //输人一条边依附的顶点及权值
           int i = LocateVex(G, v1);
           int j = LocateVex(G, v2); //确定v1和v2在G中的位置，即顶点数组的下标
           G->arcs[i][j] = w; //边<v1, v2>的权值置为w 无向图的话 =1
           G->arcs[j][i] = G->arcs[i][j]; //无向网 置<v1, v2>的对称边<v2, v1>的权值为w
       } //for
       return 1;
   } //CreateUDN
   ```

   若要建立无向图, 只需对上述算法做两处小的改动: 一是初始化邻接矩阵时, 将边的权值均初始化为0; 二是构造邻接矩阵时, 将权值w改为常量值1即可. 

   创建有向网时, 邻接矩阵是非对称的. 只需要为`G->arcs[i][j]` 赋值, 不用给对称点赋值.

   创建有向图把上面两个结合就行了.

5. **邻接矩阵表示法的优缺点**

   (1)优点:

   - 便于判断两个顶点之间是否有边， 即根据`A[i][j]` = 0或1来判断。
   - 便于计算各个顶点的度. 对无向图, 邻接矩阵第i行元素之和就是顶点i的度; 对于有向图, 第i行元素之和就是顶点i的出度, 第i列元素之和就是顶点i的入度.
   - 方便找任一顶点的所有"邻接点"(有边直接相连的顶点)

   (2) 缺点:

   - 不便于增加和删除顶点。

   - 不便于统计边的数目，需要扫描邻接矩阵所有元素才能统计完毕(尤其稀疏图)，时间复杂度为`O(n^2)`.

   - 空间复杂度高:

     如果是有向图, n个顶点需要`n^2`个单元存储边. 如果是无向图, 因其邻接矩阵是对称的, 所以对规模较大的邻接矩阵可以采用压缩存储的方法, 仅存储下三角(或上三角)的元素, 这样需要`n(n-1)/2`个单元即可. 但无论以何种方式存储, 邻接矩阵表示法的空间复杂度均为`O(n^2)`, 这对稀疏图而言尤其浪费空间.

### 6.4.2 邻接表

邻接表将邻接矩阵的n行改成n个单链表, 适合表示稀疏图.

1. **邻接表表示法**

   邻接表(Adjacency List) 是图的一种链式存储结构. 在邻接表中, 对图中每个顶点`Vi`建立一个单链表,把与`Vi `相邻接的顶点放在这个链表中. 邻接表中每个单链表的第一个结点存放有关顶点的信息, 把这一结点看成链表的表头, 其余结点存放有关边的信息, 这样邻接表便由两部分组成: 表头结点表和边表.

   (1) `表头结点表`: 由所有表头结点以顺序结构的形式存储, 以便可以随机访问任一顶点的边链表. 表头结点包括数据域(data)和链域(firstarc)两部分, 其中, 数据域用于存储顶点Vi的名称或其他有关信息; 链域用于指向链表中第一个结点(即与顶点`Vi`邻接的第一个邻接点).

   (2) `边表`: 由表示图中顶点间关系的2n个边链表组成. 边链表中边结点包括邻接点域(adjvex), 数据域(info) 和链域(nextarc) 三部分, 其中, `邻接点域`指示与顶点Vi邻接的点在`图中的位置`; 数据域存储和边相关的信息, 如权值等; 链域指示与顶点Vi邻接的下一条边的结点.

   ![1677576231336](DataStructure4.assets/1677576231336.png)

   举例: 无向图

   ![1677577196544](DataStructure4.assets/1677577196544.png)

   特点: 

   - 邻接表不唯一
   - 若无向图中有n个顶点, e条边, 则其邻接表需要n个头结点, 2e个边结点. 适合存稀疏图.
   - 无向图中的顶点Vi的度为x, 则第i个单链表的结点数是x.

   举例 有向图:

   ![1677578900180](DataStructure4.assets/1677578900180.png)

   - 图的邻接表 存储表示:

   要定义一个邻接表, 需要先定义其存放顶点的头结点和表示边的边结点. 图的邻接表存储结构说明如下：

   ```c
   //-----图的邻接表存储表示－－－－－
   #define MVNum 100    //最大顶点数
   
   typedef struct ArcNode  //边结点
   {
   	int adjvex;   //该边所指向的顶点的位置
   	struct ArcNode * nextarc; //指向下一条边的指针
   	Otherinfo info;  //和边相关的信息
   }ArcNode;
   
   typedef struct VNode{
       VerTexType data;  //顶点信息
       ArcNode *firstarc; //指向第一条依附该顶点的边的指针
   }VNode, AdjList[MVNum];
   
   typedef struct {  //邻接表
   	AdjList vertices;   //结点 数组
   	int vexnum,arcnum;  //图的当前顶点数和边数
   }ALGraph;
   ```

   
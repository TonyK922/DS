# 第8章 排序

>排序的一个主要目的是便于查找, 有序的顺序表可以采用查找效率较高的折半查找法,  又如创建树表(无
  论是二叉排序树还是B-树)的过程本身就是一个排序的过程.

## 8.1 基本概念和排序方法概述

### 8.1.1 排序的基本概念

排序: 将一组杂乱无章的数据按一定规律顺次排列起来. 即 将无序序列排列成一个有序序列(小到大 大到小)的运算.
> 若参加排序的数据结点有多个数据域, 那么排序往往是针对其中某一个域而言的.

- 排序方法的分类
![](assets/Pasted%20image%2020230306080905.png)
![](assets/Pasted%20image%2020230306081008.png)
![](assets/Pasted%20image%2020230306081027.png)
![](assets/Pasted%20image%2020230306081105.png)
![](assets/Pasted%20image%2020230306081208.png)
![](assets/Pasted%20image%2020230306081252.png)
![](assets/Pasted%20image%2020230306081409.png)
![](assets/Pasted%20image%2020230306081537.png)
![](assets/Pasted%20image%2020230306081611.png)

### 8.1.2 内部排序方法的分类

内部排序的方法很多， 但就其全面性能而言， 很难提出一种被认为是最好的方法， 每一种方法都有各自的优缺点， 适合在不同的环境（如记录的初始排列状态等） 下使用。
内部排序的过程是一个逐步扩大记录的有序序列长度的过程。在排序的过程中， 可以将排序记录区分为两个区域：有序序列区和无序序列区。
使有序区中记录的数目增加一个或几个的操作称为一趟排序。
根据逐步扩大记录有序序列长度的原则不同， 可以将内部排序分为以下几类。
(1) 插入类： 将无序子序列中的一个或几个记录＂插入” 到有序序列中， 从而增加记录的有序子序列的长度。主要包括直接插入排序、折半插入排序和希尔排序。
(2) 交换类：通过“交换“ 无序序列中的记录从而得到其中关键字最小或最大的记录，并将它加入到有序子序列中，以此方法增加记录的有序子序列的长度。主要包括冒泡排序和快速排序。
(3) 选择类：从记录的无序子序列中”选择“ 关键字最小或最大的记录，并将它加入到有序子序列中， 以此方法增加记录的有序子序列的长度。主要包括简单选择排序、树形选择排序和堆排序。
(4) 归并类：通过“归并“ 两个或两个以上的记录有序子序列， 逐步增加记录有序序列的长度。2-路归并排序是最为常见的归并排序方法。
(5)分配类：是唯一一类不需要进行关键字之间比较的排序方法， 排序时主要利用分配和收集两种基本操作来完成。基数排序是主要的分配类排序方法。

### 8.1.3 待排序记录的存储方式

(1) 顺序表： 记录之间的次序关系由其存储位置决定， 实现排序需要移动记录。
(2) 链表：记录之间的次序关系由指针指示，实现排序不需要移动记录，仅需修改指针即可。这种排序方式称为链表排序。
(3) 待排序记录本身存储在一组地址连续的存储单元内， 同时另设一个指示各个记录存储位置的地址向量，在排序过程中不移动记录本身，而移动地址向撒中这些记录的“地址”，在排序结束之后再按照地址向量中的值调整记录的存储位置。这种排序方式称为地址排序。
在本章的讨论中， 除基数排序外， 待排序记录均按上述第一种方式存储，且为了讨论方便，设记录的关键字均为整数。

本章排序算法基于 顺序表存储的存储结构.
```c
#define MAXSIZE 20  //顺序表的最大长度
typedef int KeyType; //定义关键字类型为整型

typedef struct {
	KeyType key;   //关键字项
	InfoType otherinfo; //其他数据项
}RedType;   //记录类型

typedef struct{
	RedType r[MAXSIZE+1]; //r[O]闲置或用做哨兵单元
	int length;  //顺序表长度
}SqList;

```

## 8.2 插入排序

插入排序的基本思想是：每一趟将一个待排序的记录， 按其关键字的大小插入到已经排好序的一组记录的适当位置上，直到所有待排序记录全部插入为止。
可以选择不同的方法在已排好序的记录中寻找插入位置. 根据`查找方法`的不同, 有多种插入排序方法,   这里仅介绍三种方法: 直接插入排序, 折半插入排序和希尔排序。
![](assets/Pasted%20image%2020230306101317.png)
![](assets/Pasted%20image%2020230306101516.png)
![](assets/Pasted%20image%2020230306101819.png)
插入的位置:
![](assets/Pasted%20image%2020230306101947.png)
查找插入位置的三种方法:
![](assets/Pasted%20image%2020230306102119.png)

### 8.2.1 直接插人排序

直接插入排序(Straight Insertion Sort) 是一种最简单的排序方法, 其基本操作是将一条记录插入到已排好序的有序表中, 从而得到一个新的, 记录数量增1的有序表.
![](assets/Pasted%20image%2020230306104038.png)
使用哨兵查找优化:
![](assets/Pasted%20image%2020230306104248.png)
**算法8.1 直接插入排序**
![](assets/Pasted%20image%2020230306104913.png)
算法描述:
```c
void InsertSort(SqList *L)
{
	int i,j;

	for(i = 2; i<=L->length; ++i)
	{
		if(L->r[i].key < L->r[i-1].key)  //＂<＂需将r[i]插人有序子表
		{
			L->r[0] = L->[i];  //设置哨兵
			for(j = i-1; L->r[0].key < L->r[j].key; --j) 
			{
				L->r[j+1] = L->r[j]; //大的依次后移
			}
			L->r[j+1] = L->r[0]; //上面循环最后一次执行了--j 这里j+1是对的位置
		}
	}
}
```
从时间来看, 排序的基本操作为: 比较两个关键字的大小和移动记录.
直接插入排序的时间复杂度为O(n^2).
只需要一个记录的辅助空间`r[0]`所以空间复杂度为O(1).
［算法特点］
(1) 稳定排序.
(2) 算法简便, 且容易实现.
(3) 也适用千链式存储结构, 只是在单链表上无需移动记录, 只需修改相应的指针.
(4)  更适合于初始记录基本有序(正序)的情况, 当初始记录无序, n较大时, 此算法时间复杂度较高, 不宜采用.

### 8.2.2 折半插人排序

直接插入排序采用顺序查找法查找当前记录在已排好序的序列中的插入位置, 从7.2节的讨论中可知, 这个“查找" 操作可利用“折半查找”来实现, 由此进行的插入排序称之为折半插入排序(Binary Insertion Sort).
**算法8.2 折半插入排序**
![](assets/Pasted%20image%2020230306155857.png)
```c
void BInsertSort(SqList *L)
{
	int i = 0, j = 0;

	for(i = 2; i<=L->length; ++i) //依次插入2到n个元素
	{
		L->r[0] = L->r[i]; //需要被插入的元素存到哨兵
		int low = 1, high = i-1; //二分法的两个位置指针.
		
		while(low <= high)   //low > high的时候查找就结束了.
		{
			int mid = (low + high) >> 1; //除以2
			if (L->r[0].key < L->r[mid].key)
				high = mid - 1;
			else
				low = mid + 1;
		} //找到了high+1为插入位置
		for(j = i-1;j>=high + 1; --j) //high+1往后的依次移动
			L->[j+1] = L->r[j];
		L->r[high+1] = L->r[0]; //插入
	}
}
```
从时间上比较, 折半查找比顺序查找快, 所以就平均性能来说, 折半插入排序优于直接插入排序.
![](assets/Pasted%20image%2020230306161442.png)
折半插入排序的对象移动次数与直接插入一样, 依赖对象的初始排列
折半插入, 折半的只是查找比较的次数, 找到位置移动次数是一样的.
折半插入排序平均性能优于直接插入排序.
【算法特点】
(1) 稳定排序。
(2) 因为要进行折半查找， 所以只能用于顺序结构，不能用于链式结构。
(3) 适合初始记录无序、n较大时的情况。

### 8.2.3 希尔排序

希尔排序(Shell's Sort)又称"缩小增量排序"(DiminishingIn crement Sort), 是插入排序的一种, 因D.L.Shell于1959 年提出而得名。

直接插入排序, 当待排序的记录个数较少且待排序序列的关键字基本有序时, 效率较高. 希尔排序基于以上两点, 从“减少记录个数”和“序列基本有序”两个方面对直接插入排序进行了改进.

**算法8.3 希尔排序**

【算法步骤】
希尔排序实质上是采用分组插入的方法. 先将整个待排序记录序列分割成几组, 从而减少参与
直接插入排序的数据量, 对每组分别进行直接插入排序, 然后增加每组的数据量, 重新分组. 这样
当经过几次分组排序后, 整个序列中的记录“基本有序”时, 再对全体记录进行一次直接插入排序. 
希尔对记录的分组, 不是简单地”逐段分割＂, 而是将相隔某个“增量”的记录分成一组。
![](assets/Pasted%20image%2020230306163107.png)
例子帮助理解:
![](assets/Pasted%20image%2020230306163523.png)
(1) 第一趟取增量d3=5, 所有间隔为5的记录分在同一组, 全部记录分成5组, 在各个组中分别进行直接插入排序, 排序结果如图的第4行所示.
(2) 第二趟取增量d2=3, 所有间隔为3的记录分在同一组, 全部记录分成3组, 在各个组中分别进行直接插入排序, 排序结果如图的第6行所示.
(3)第三趟取增量d1=1, 对整个序列进行一趟直接插入排序, 排序完成.

![](assets/Pasted%20image%2020230306164204.png)
特点:
- 一次移动, 移动位置较大, 跳跃式地接近排序后的最终位置.
- 最后一次只需少量移动
- 增量序列必须是递减的, 最后一个必为1
- 增量序列应该是互质的.
```c
void ShellInsert(SqList *L, int dk)
{
	//对顺序表L做`一趟`增量是dk的希尔插入排序 dk是步长因子
	for(int i = dk+1; i<=L->length; ++i)
	{
		if(L->r[i].key<L->r[i-dk].key) //需将L->r[i]插入有序增扯子表
		{
			L->r[0] = L->r[i]; //暂存在L->r[O]
			for(int j=i-dk; j>0 && (L->r[0].key < L->r[j].key); j-=dk) 
				L->r[j+dk] = L->r[j]; //分组的直接插入排序
			L->[j+dk] = L->r[0]; //位置移完把r[i]插到正确位置
		}
	}
	
	
}
//dk值依次存于dlta[t]中
void ShellSort(SqList *L, int dlta[], int t)
{
	for(int k = 0; k < t; ++k)
		ShellInsert(L, dlta[k]); //一趟增址为dt[t]的希尔插入排序
}
```
![](assets/Pasted%20image%2020230306170205.png)
算法特点
(1) 记录跳跃式地移动导致排序方法是不稳定的.
(2) 只能用于顺序结构, `不能用于链式结构`.
(3) 增量序列可以有各种取法, 但应该使增量序列中的值没有除1之外的公因子, 并且最后一个增量值必须等于1.
(4) 记录总的比较次数和移动次数都比直接插入排序要少, n越大时, 效果越明显. 所以适合初始记录无序, n较大时的情况.

## 8.3 交换排序

交换排序的基本思想是: `两两比较`待排序记录的关键字, 一旦发现两个记录不满足次序要求时则进行交换, 直到整个序列全部满足要求为止. 
本节首先介绍基于简单交换思想实现的冒泡排序, 然后给出另一种在此基础上进行改进的排序方法一一快速排序.

### 8.3.1 冒泡排序

冒泡排序(Bubble Sort)是一种最简单的交换排序方法, 它通过两两比较相邻记录的关键字, 如果发生逆序, 则进行交换, 从而使关键字小的记录如气泡一般逐渐往上"漂浮"(左移)或者使关键字大的记录如石块一样逐渐向下"坠落"(右移).

```c
void BubbleSort(SqList *L)
{
	//对顺序表L做冒泡排序
	int m = L->length - 1, flag = 1; //flag用来标记某一趟排序是否发生交换
	while ((m > 0) && (flag==1))
	{
		flag = 0; //flag置为0,如果本趟排序没有发生交换，则不会执行下一趟排序
		for (j=1; j<=m; j ++)
		{
			if(L->r[j].key > L->r[j+1].key)
			{
				flag = 1; //flag置为1, 表示本趟排序发生了交换
				RedType x = L->r[j];
				L->r[j] = L->r[j+1];
				L->r[j+1] = x;
			}
			m--; 
		}
	} //while
}
//写法二:
void bubble_Sort(SqList *L)
{
	int i = 1, j = 1, flag = 1;
	int n = L->length - 1;
	for(; (i <= n - 1) && (1 == flag) ; i++)
	{
		//if(!flag) break; //上一趟已经没有进行交换了 结束		
		flag = 0; //flag置为0,如果本趟排序没有发生交换，则不会执行下一趟排序
		for(;j <= i; j++)//for(;j <= n - i; j++)
		{
			if(L->r[j].key > L->r[j+1].key)
			{
				flag = 1; //flag置为1, 表示本趟排序发生了交换
				RedType x = L->r[j];
				L->r[j] = L->r[j+1];
				L->r[j+1] = x;
			}
		}
	}
}
```
时间复杂度为`O(n^2)`. 空间复杂度为O(1).
`［算法特点］`
(1) 稳定排序.
(2) 可用于链式存储结构.
(3) 移动记录次数较多, 算法平均时间性能比直接插入排序差. 当初始记录无序, n较大时, 此算法不宜采用.

### 8.3.2 快速排序

快速排序(Quick Sort) 是由冒泡排序改进而得的. 在冒泡排序过程中, 只对相邻的两个记录进行比较, 因此每次交换两个相邻记录时只能消除一个逆序. 如果能通过两个(不相邻)记录的一次交换, 消除多个逆序, 则会大大加快排序的速度. 快速排序方法中的一次交换可能消除多个逆序.

**算法8.5 快速排序**

基本思想:
- 任取一个元素(如: 第一个) 为中心.(pivot) 设其关键字为`pivotkey`. 
- 所有比它小的元素一律前放, 比它大的元素一律后防. 形成左右两个子表. 
- 对各子表重新选择中心元素 并依此规则调整.
- 直到每个子表只剩一个元素
![](assets/Pasted%20image%2020230306215246.png)
通过一趟排序, 把待排序记录分割成独立的两部分, 其中一部分的记录关键字均小于另一部分记录的关键字. 则可分别对着两部分记录进行排序, 以达到整个序列有序.

具体步骤:
![](assets/Pasted%20image%2020230306215721.png)
看个例子:
已知待排序记录的关键字序列为{49, 38, 65, 97, 76, 13, 27, 49}, 请给出用快速排序法进行排序的过程.
![](assets/Pasted%20image%2020230306220311.png)
把1号位置作为中心, 移到0号, 1号空下来了, 开始从high位置比, 大于中心关键字, high--, 再比, 找到小于中心关键字的, 移到1号位置. 反复直到low > high
```c
void QSort(SqList *L, int low, int high);
int Partition(SqList *L, int low, int high);
void QuickSort(SqList *L)
{ //对顺序表L做快速排序
	QSort(L, 1, L->length); //调用QSort
}

void QSort(SqList *L, int low, int high)
{ //调用前置初值： low= 1; high= L->length;
	//对顺序表L中的子序列L->r[low .. high]做快速排序
	if(low < high)  //长度大于1
	{
		//将L.r[low.. high] 一分为二，pivotloc是枢轴位置
		int pivotloc = Partition(L, low, high); 
		QSort(L, low, pivotloc - 1);  //对左子表递归排序
		QSort(L, pivotloc +1 , high)  //对右子表递归排序
	}
}

int Partition(SqList *L, int low, int high)
{ ///对顺序表L中的子表r[low .. high]进行一趟排序，返回枢轴位置
	L->r[0] = L->r[low];  //用子表的第一个记录做枢轴记录
	KeyType pivotkey = L->r[low].key; //枢轴记录关键字保存在pivotkey中
	while(low < high) //从表的两端交替地向中间扫描
	{
		while(low < high && L->r[high].key >= pivotkey) 
			high--;
			
		L->r[low] = L->r[high];  //将比枢轴记录小的记录移到低端
		while(low < high && L->r[low].key <= pivotkey)
			low++;

		L->r[high] = L->r[low]; //将比枢轴记录大的记录移到高端
	} //while
	L->r[low] = L->r[0];  //枢轴记录到位
	return low;  //／返回枢轴位置	
}
```
平均情况下， 快速排序的时间复杂度为O(nlog2 n).
快速排序是递归的, 执行时需要有一个栈来存放相应的数据. 最大递归调用次数与递归树的深度一致，所以最好情况下的空间复杂度为O(log2 n) ,最坏情况下为O(n).

【算法特点】
(1) 记录非顺次的移动导致排序方法是不稳定的.
(2) 排序过程中需要定位表的下界和上界, 所以适合用于顺序结构, 很难用于链式结构.
(3) 当`n较大`时, 在平均情况下快速排序是`所有内部排序方法`中速度`最快`的一种, 所以其适合初始记录无序, n较大时的情况。

- 注意:
![](assets/Pasted%20image%2020230307000925.png)
![](assets/Pasted%20image%2020230307001134.png)

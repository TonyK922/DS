# 第7章 查找

![1677847602670](DataStructure5.assets/1677847602670.png)

## 7.1 查找的基本概念

(1) 查找表
查找表是由`同一类型的数据元素(或记录)`构成的集合. 由于"集合"中的数据元素之间存在着完全松散的关系, 因此查找表是一种非常灵便的数据结构, 可以利用其他的数据结构来实现, 比如本章将要介绍的线性表, 树表及散列表等.

(2) 关键字
关键字是数据元素(或记录) 中某个数据项的值, 用它可以标识一个数据元素(或记录). 若此关键字可以`唯一地标识一个记录`, 则称此关键字为`主关键字`(对不同的记录, 其主关键字均不同). 反之, 称用以识别`若干记录`的关键字为`次关键字`. 当数据元素只有一个数据项时, 其关键字即为该数据元素的值.

(3) 查找
查找是指根据给定的某个值, 在查找表中确定一个其关键字等于给定值的记录或数据元素. 若表中存在这样的一个记录, 则称查找成功, 此时查找的结果可给出整个记录的信息, 或指示该记录在查找表中的位置; 若表中不存在关键字等于给定值的记录, 则称查找不成功, 此时查找的结果可给出一个"空"记录或"空"指针.

(4) 动态查找表和静态查找表
若在查找的同时对表做修改操作(如插入和删除), 则相应的表称之为动态查找表, 否则称之为静态查找表. 换句话说, 动态查找表的表结构本身是在查找过程中动态生成的, 即在创建表时, 对于给定值, 若表中存在其关键字等于给定值的记录, 则查找成功返回; 否则插入关键字等于给定值的记录.

(5) 平均查找长度
为确定记录在查找表中的位置，需和给定值进行比较的关键字个数的期望值， 称为查找算法在查找成功时的平均查找长度(Average Search Length, ASL).

![1677850560373](DataStructure5.assets/1677850560373.png)

查找的方法 取决于查找表的结构, 即表中数据元素是依何种关系组织在一起的.

对于查找表来说, 在集合中查询或检索一个"特定的"数据元素时, 若无规律可循, 则只能对集合中的元素逐一辨认直到找到为止.

而这样的"查询"或"检索"是任何计算机应用系统中使用频度都很高的操作, 因此设法提高查找表的查找效率, 是本章讨论的出发点.

为了提高查找效率, 一个办法是在构造查找表时, 在集合中的数据元素之间人为的加上某种确定的约束关系.

## 7.2 线性表的查找

在查找表的组织方式中, 线性表是最简单的一种. 分三种 : 顺序查找、折半查找和分块查找.

### 7.2.1 顺序查找

顺序查找(Sequential Search)的查找过程为: 从表的一端开始, 依次将记录的关键字和给定值进行比较, 若某个记录的关键字和给定值相等, 则查找成功; 反之, 若扫描整个表后, 仍未找到关键字和给定值相等的记录, 则查找失败.

顺序查找方法既适用于线性表的`顺序存储结构`，又适用于线性表的`链式存储结构`. 静态查找表, 表内元素直接无序.

下面以顺序表为例:

数据元素类型定义如下：

```c
typedef struct {
	KeyType key;   //关键字域
	InfoType otherinfo; //其他域
} ElemType;
```

顺序表定义:

```c
typedef struct{ 
	ElemType *R;  //存储空间基地址
	int length;   //当前长度
}SSTable;
SSTable ST;
```

![1677851861374](DataStructure5.assets/1677851861374.png)

- 算法7.1 顺序查找

```c
int Search_Seq(SSTable ST,KeyType key)
{
    //在顺序表ST中顺序查找其关键字等千key的数据元素. 若找到,则函数值为该元素在表中的位置,否则为0
    for(int i = ST.length; i>=1; --i)
        if( key == ST.R[i].key ) return i;
    return 0;
}
//或者:
int Search_Seq(SSTable ST,KeyType key)
{
    int i = -1;
    for(i = ST.length; ST.R[i].key != key && i>0; --i);   
    if(i > 0)	return i;
    else return 0;
 }
```

改进方法是查找之前先对ST.R[0]的关键字赋值key, 在此, ST.R[0]起到了监视哨的作用,  如算法7.2所示。

- 算法7.2 设置监视哨的顺序查找

  ![1677852568270](DataStructure5.assets/1677852568270.png)

```c
int Search_Seq(SSTable ST, KeyType key)
{
    //在顺序表ST中顺序查找其关键字等千key的数据元素. 若找到,则函数值为该元素在表中的位置,否则为0
    ST.R[0].key = key;
    int i = -1;
    for(i = ST.length; ST.R[i].key != key; --i);   
    return i;
}
```

通过设置监视哨, 免去查找过程中每一步都要检测整个表是否查找完毕. 然而实践证明, 这个改进能使顺序查找在ST.length >= 1000时, 进行一次查找所需的平均时间几乎减少一半.

算法7.2 和算法7.1 的时间复杂度一样为O(n). 空间复杂度O(1).

顺序查找的优点是: 算法简单, 对表结构无任何要求, 既适用于顺序结构, 也适用千链式结构, 无论记录是否按关键字有序均可应用. 其缺点是: 平均查找长度较大, 查找效率较低, 所以当n很大时, 不宜采用顺序查找.

![1677853067739](DataStructure5.assets/1677853067739.png)

### 7.2.2 折半查找

折半查找(BinarySearhc )也称二分查找, 它是一种效率较高的查找方法. 但是, 折半查找要求线性表`必须采用顺序存储结构`, 而且`表中元素按关键字有序排列`。

折半查找的查找过程为: 从表的中间记录开始, 如果给定值和中间记录的关键字相等， 则查找成功；如果给定值大于或者小于中间记录的关键字, 则在表中大于或小于中间记录的那一半中查找，这样重复操作， 直到查找成功，或者在某一步中查找区间为空， 则代表查找失败。

折半查找每一次查找比较都使查找范围缩小一半，与顺序查找相比，很显然会提高查找效率。为了标记查找过程中每一次的查找区间，下面分别用low和high来表示当前查找区间的下界和上界，mid为区间的中间位置。

![1677901203055](DataStructure5.assets/1677901203055.png)

\[算法步骤]:

![1677901344259](DataStructure5.assets/1677901344259.png)

```c
int Search_Bin(SSTable ST, KeyType key)
{
    //在有序表ST中折半查找其关键字等于key的数据元素.若找到,则函数值为该元素在表中的位置,否则为0
    int low = 1, high = ST.length;  //置区间初值
    while(low <= high)  //注意是<=
    {
        int mid = (low+high)>>1; //移位比除法快
        if(ST.R[mid].key == key) return mid; //找到
        else if(key < ST.R[mid].key)  //缩小查找区间
            high = mid-1;              //在前半区查
        else
            low = mid+1;              //在后半区查
    }
    return 0;
}
//递归写法:
int Search_Bin(SSTable ST, KeyType key, int low, int high)
{
    if(low > high) return 0;
    
    int mid = (low + high) >> 1;
    if(key == ST.R[mid].key) return mid;
    else if(key < ST.R[mid].key)
    {
        Search_Bin(ST, key, low, mid-1);
    }
    else
        Search_Bin(ST, key, mid+1, high);
}
```

因为二分法查找期望是`2^x <= n` 所以, 折半查找的时间复杂度为O(log2 n). 可见, 二分法查找的效率比顺序查找高，但折半查找只适用于有序表,且限于顺序存储结构(链表无效).

折半查找的优点是：比较次数少，查找效率高。其缺点是：对表结构要求高，只能用于顺序存储的有序表。查找前需要排序，而排序本身是一种费时的运算。同时为了保持顺序表的有序性，对有序表进行插入和删除时，平均比较和移动表中一半元素，这也是一种费时的运算。因此，折半查找不适用于数据元素经常变动的线性表。

### 7.2.3 分块查找

分块查找(Blocking Search) 又称索引顺序查找，这是一种性能介于顺序查找和折半查找之间的一种查找方法。在此查找法中，除表本身以外，尚需建立一个“索引表”。如图:

![1677918927369](DataStructure5.assets/1677918927369.png)

上图就是一个表及其索引表，表中含有18 个记录， 可分成3 个子表对每个子表（或称块）建立一个索引项，其中包括两项内容：`关键字项`（其值为该子表内的最大关键字） 和`指针项`（指示该子表的第一个记录在表中位置）。索引表按`关键字有序`，则表或者有序或者分块有序。

所谓“ 分块有序” 指的是第二个子表中所有记录的关键字均大于第一个子表中的最大关键字，第三个子表中的所有关键字均大于第二个子表中的最大关键字，……，依次类推。

![1677919380615](DataStructure5.assets/1677919380615.png)

- 查询过程

  先确定待查记录所在哪个块(顺序或二分法查找), 再于块内查找(顺序查找).

由于由索引项组成的索引表按关键字有序，则确定块的查找可以用顺序查找，亦可用折半查找，而块中记录是任意排列的，则在块中只能是顺序查找。
由此， 分块查找的算法为顺序查找和折半查找两种算法的简单合成。

分块查找的优点是：在表中插入和删除数据元素时，只要找到该元素对应的块，就可以在该块内进行插入和删除运算。由于块内是无序的，故插入和删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。其缺点是：要增加一个索引表的存储空间并对初始索引表进行排序运算。

> 分块查找比顺序查找快, 但比二分法要慢.

- 三种查找的比较

  ![1677919455519](DataStructure5.assets/1677919455519.png)

## 7.3 树表的查找

折半查找效率较高, 但由于折半查找要求表中记录按关键字有序排列, 且不能用链表做存储结构, 因此, 当表的插入或删除操作频繁时, 为维护表的有序性, 需要移动表中很多记录. 这种由移动记录引起的额外时间开销, 就会抵消折半查找的优点. 所以, 线性表的查找更适用于`静态查找表`, 若要对动态查找表进行高效率的查找, 可采用几种`特殊的二叉树`作为查找表的组织形式, 在此将它们统称为树表.

![1677919914657](DataStructure5.assets/1677919914657.png)

### 7.3.1 二叉排序树

二叉排序树(Binary Sort Tree) 又称`二叉查找树`, 或二叉搜索树, 它是一种对`排序`和`查找`都很有用的特殊二叉树.

1. 二叉排序树的定义

   二叉排序树或者是一棵空树, 或者是具有下列性质的二叉树: 

   (1) 若它的左子树不空，则左子树上所有结点的值均小千它的根结点的值；
   (2) 若它的右子树不空，则右子树上所有结点的值均大千它的根结点的值；
   (3) 它的左, 右子树也分别为二叉排序树。

   二叉排序树是递归定义的. 由定义可以得出二叉排序树的一个`重要性质`: 
   中序遍历一棵二叉树时可以得到一个结点值`递增`的有序序列.

   ![1677923603717](DataStructure5.assets/1677923603717.png)

   因为二叉排序树的操作要根据结点的关键字域来进行, 所以下面给出了每个结点的数据域的类型定义(包括关键字项和其他数据项):

   ```c
   //-----二叉排序树的二叉链表存储表示------
   typedef struct
   {
       KeyType key;  //关键字项
       InfoType otherinfo; //其他数据项   
   }ElemType;  //每个结点的数据域的类型
   typedef struct BSTNode{
       ElemType data;   //每个结点的数据域包括关键字项和其他数据项
       struct BSTNode *lchild,*rchild;  //左右孩子指针
   };
   ```

   

